<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV.js Parity Test Harness</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        #status {
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 4px;
        }
        .loading { color: #f5923e; }
        .ready { color: #5cb85c; }
        .error { color: #d9534f; }
        canvas {
            border: 1px solid #444;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>OpenCV.js Parity Test Harness</h1>
    <div id="status" class="loading">Loading libraries...</div>
    <div id="details"></div>

    <!-- Canvas for image operations -->
    <canvas id="canvas" style="display: none;"></canvas>

    <!-- Load OpenCV.js from local cache (avoids CDN/network issues) -->
    <script async src="/cache/opencv.js" onerror="console.error('[OpenCV.js] Script load error')"></script>

    <!-- Main test harness script -->
    <script type="module">
        // Global state
        window.testHarnessReady = false;
        window.opencv_js_ready = false;
        window.opencv_rust_ready = false;
        window.testImages = {};
        window.initSteps = []; // Track initialization steps
        window.debugLog = []; // Store all logs for extraction

        const statusEl = document.getElementById('status');
        const detailsEl = document.getElementById('details');
        const startTime = performance.now();

        function getTimestamp() {
            return `[${(performance.now() - startTime).toFixed(2)}ms]`;
        }

        // Enhanced logging that stores in window.debugLog for extraction
        function log(category, message, level = 'log') {
            const timestamped = `${getTimestamp()} [${category}] ${message}`;
            const entry = { time: performance.now() - startTime, category, message, level, timestamp: new Date().toISOString() };
            window.debugLog.push(entry);

            if (level === 'error') {
                console.error(timestamped);
            } else if (level === 'warn') {
                console.warn(timestamped);
            } else {
                console.log(timestamped);
            }

            return timestamped;
        }

        function updateStatus(message, className = 'loading') {
            statusEl.textContent = message;
            statusEl.className = className;
            log('Test Harness', message);
            window.initSteps.push({ time: performance.now() - startTime, message, className });
        }

        function addDetails(message) {
            const p = document.createElement('p');
            p.textContent = message;
            detailsEl.appendChild(p);
            log('Details', message);
        }

        // Log memory usage if available
        function logMemoryUsage(label) {
            if (performance.memory) {
                const used = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
                const total = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
                log('Memory', `${label}: ${used}MB used / ${total}MB total`);
            }
        }

        // Function to extract all logs
        window.extractDebugLog = function() {
            console.log('\n=== DEBUG LOG DUMP ===');
            window.debugLog.forEach(entry => {
                console.log(`[${entry.time.toFixed(2)}ms] [${entry.category}] ${entry.message}`);
            });
            console.log('=== END DEBUG LOG ===\n');
            return window.debugLog;
        };

        // Wait for OpenCV.js to load with extensive polling and logging
        async function waitForOpenCVJs() {
            log('OpenCV.js', '=== Starting OpenCV.js load process ===');

            // Check if already loaded
            if (typeof cv !== 'undefined' && cv.Mat) {
                log('OpenCV.js', 'Already loaded! cv.Mat is available');
                logMemoryUsage('After OpenCV.js load');
                return;
            }

            log('OpenCV.js', 'Not loaded yet, checking script tag...');

            // Check script tag
            const scriptTag = document.querySelector('script[src="/cache/opencv.js"]');
            if (scriptTag) {
                log('OpenCV.js', `Script tag found: ${scriptTag.src}`);
                log('OpenCV.js', `Script readyState: ${scriptTag.readyState || 'undefined'}`);
                log('OpenCV.js', `Script loaded: ${scriptTag.hasAttribute('data-loaded')}`);
            } else {
                log('OpenCV.js', 'ERROR: Script tag not found!', 'error');
            }

            // Check window.cv status
            log('OpenCV.js', `window.cv type: ${typeof cv}`);
            log('OpenCV.js', `window.cv exists: ${typeof cv !== 'undefined'}`);
            if (typeof cv !== 'undefined') {
                log('OpenCV.js', `cv.Mat exists: ${typeof cv.Mat !== 'undefined'}`);
                log('OpenCV.js', `cv keys: ${Object.keys(cv).slice(0, 10).join(', ')}...`);
            }

            // Set up callback as backup
            log('OpenCV.js', 'Setting up onOpenCVReady callback...');
            let callbackFired = false;
            window.onOpenCVReady = () => {
                callbackFired = true;
                log('OpenCV.js', '✓ onOpenCVReady callback fired!');
            };

            // Poll for cv object
            log('OpenCV.js', 'Starting polling for cv object (check every 100ms for 30s)...');
            const maxAttempts = 300; // 30 seconds
            const pollInterval = 100; // 100ms

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                // Log every 2 seconds
                if (attempt % 20 === 0 && attempt > 0) {
                    log('OpenCV.js', `Still polling... ${attempt * pollInterval}ms elapsed`);
                    log('OpenCV.js', `  cv exists: ${typeof cv !== 'undefined'}`);
                    log('OpenCV.js', `  callback fired: ${callbackFired}`);
                }

                // Check if cv.Mat is available
                if (typeof cv !== 'undefined' && cv.Mat) {
                    log('OpenCV.js', `✓ SUCCESS! cv.Mat detected after ${attempt * pollInterval}ms`);
                    log('OpenCV.js', `  Callback fired: ${callbackFired}`);
                    logMemoryUsage('After OpenCV.js load');
                    return;
                }

                await new Promise(resolve => setTimeout(resolve, pollInterval));
            }

            // Timeout
            log('OpenCV.js', '✗ TIMEOUT after 30 seconds', 'error');
            log('OpenCV.js', `Final state - cv exists: ${typeof cv !== 'undefined'}`, 'error');
            log('OpenCV.js', `Final state - callback fired: ${callbackFired}`, 'error');
            if (typeof cv !== 'undefined') {
                log('OpenCV.js', `cv properties: ${Object.keys(cv).join(', ')}`, 'error');
            }

            throw new Error('OpenCV.js load timeout - cv.Mat not available after 30s');
        }

        // Load our WASM module with extensive logging
        async function loadOpenCVRust() {
            try {
                log('WASM', '=== Starting WASM module load ===');
                logMemoryUsage('Before WASM load');

                log('WASM', 'Step 1: Attempting to import /pkg/opencv_rust.js...');

                // Import our WASM module (absolute path from web root)
                const importStart = performance.now();
                const module = await import('/pkg/opencv_rust.js');
                const importDuration = performance.now() - importStart;

                log('WASM', `Step 1 COMPLETE: Module imported in ${importDuration.toFixed(2)}ms`);
                log('WASM', `Module exports: ${Object.keys(module).join(', ')}`);
                logMemoryUsage('After module import');

                log('WASM', 'Step 2: Initializing WASM (calling module.default())...');
                const initStart = performance.now();

                await module.default();

                const initDuration = performance.now() - initStart;
                log('WASM', `Step 2 COMPLETE: WASM initialized in ${initDuration.toFixed(2)}ms`);
                logMemoryUsage('After WASM init');

                // Try to initialize GPU (may fail in headless mode, that's OK)
                log('WASM', 'Step 3: Checking for GPU support...');
                try {
                    if (module.initGpu) {
                        log('WASM', 'Step 3a: initGpu found, attempting GPU initialization...');
                        const gpuStart = performance.now();

                        await module.initGpu();

                        const gpuDuration = performance.now() - gpuStart;
                        log('WASM', `Step 3a COMPLETE: GPU initialized in ${gpuDuration.toFixed(2)}ms`);
                        addDetails('✓ GPU initialized');
                        logMemoryUsage('After GPU init');
                    } else {
                        log('WASM', 'Step 3b: No initGpu function found (CPU mode)');
                        addDetails('ℹ CPU mode (no GPU function)');
                    }
                } catch (e) {
                    log('WASM', `Step 3 FAILED: GPU init failed (will use CPU): ${e.message}`, 'warn');
                    log('WASM', `GPU error stack: ${e.stack}`, 'warn');
                    addDetails('⚠ GPU init failed (will use CPU): ' + e.message);
                }

                // Store module globally
                log('WASM', 'Step 4: Storing module globally...');
                window.opencvRust = module;
                window.opencv_rust_ready = true;
                log('WASM', 'Step 4 COMPLETE: Module stored as window.opencvRust');
                logMemoryUsage('After storing module');

                log('WASM', '=== WASM module load COMPLETE ===');
                return module;

            } catch (error) {
                log('WASM', '=== WASM LOAD FAILED ===', 'error');
                log('WASM', `Error message: ${error.message}`, 'error');
                log('WASM', `Error stack: ${error.stack}`, 'error');
                log('WASM', `Full error: ${JSON.stringify(error, null, 2)}`, 'error');
                logMemoryUsage('After WASM error');

                throw new Error(`Failed to load opencv-rust: ${error.message}`);
            }
        }

        // Load test image
        window.loadTestImage = async function(imagePath) {
            const fullPath = `/tests/fixtures/${imagePath}`;

            // Check cache
            if (window.testImages[imagePath]) {
                return window.testImages[imagePath];
            }

            return new Promise((resolve, reject) => {
                const img = new Image();

                img.onload = () => {
                    // Draw to canvas to get ImageData
                    const canvas = document.getElementById('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, img.width, img.height);

                    // Cache it
                    window.testImages[imagePath] = imageData;

                    resolve(imageData);
                };

                img.onerror = () => {
                    reject(new Error(`Failed to load image: ${fullPath}`));
                };

                img.src = fullPath;
            });
        };

        // Convert OpenCV.js Mat to ImageData
        window.matToImageData = function(mat) {
            const canvas = document.getElementById('canvas');
            cv.imshow(canvas, mat);
            const ctx = canvas.getContext('2d');
            return ctx.getImageData(0, 0, mat.cols, mat.rows);
        };

        // Convert ImageData to OpenCV.js Mat
        window.imageDataToMat = function(imageData) {
            const canvas = document.getElementById('canvas');
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            const ctx = canvas.getContext('2d');
            ctx.putImageData(imageData, 0, 0);
            return cv.imread(canvas);
        };

        // Main initialization with extensive logging
        async function initialize() {
            try {
                log('Init', '=== INITIALIZATION START ===');
                log('Init', `Browser: ${navigator.userAgent}`);
                log('Init', `WebGPU available: ${!!navigator.gpu}`);
                log('Init', `Platform: ${navigator.platform}`);
                log('Init', `Language: ${navigator.language}`);
                logMemoryUsage('Initialization start');

                updateStatus('Loading OpenCV.js...', 'loading');
                log('Init', '=== PHASE 1: Loading OpenCV.js ===');

                const opencvStart = performance.now();
                await waitForOpenCVJs();
                const opencvDuration = performance.now() - opencvStart;

                window.opencv_js_ready = true;
                log('Init', `=== PHASE 1 COMPLETE: OpenCV.js loaded in ${opencvDuration.toFixed(2)}ms ===`);

                // Get OpenCV.js version info
                try {
                    const buildInfo = cv.getBuildInformation();
                    const version = buildInfo.split('\n')[0];
                    log('Init', `OpenCV.js version: ${version}`);
                    addDetails('✓ OpenCV.js loaded: ' + version);
                } catch (e) {
                    log('Init', `Could not get OpenCV.js build info: ${e.message}`, 'warn');
                    addDetails('✓ OpenCV.js loaded');
                }

                updateStatus('Loading opencv-rust WASM...', 'loading');
                log('Init', '=== PHASE 2: Loading opencv-rust WASM ===');

                const wasmStart = performance.now();
                await loadOpenCVRust();
                const wasmDuration = performance.now() - wasmStart;

                log('Init', `=== PHASE 2 COMPLETE: WASM loaded in ${wasmDuration.toFixed(2)}ms ===`);
                addDetails('✓ opencv-rust WASM loaded');

                // All ready
                window.testHarnessReady = true;
                const totalDuration = performance.now() - startTime;
                updateStatus('✓ Test harness ready', 'ready');
                addDetails(`Ready for tests! Total init time: ${totalDuration.toFixed(2)}ms`);

                log('Init', '=== INITIALIZATION COMPLETE ===');
                log('Init', `Total time: ${totalDuration.toFixed(2)}ms`);
                log('Init', `OpenCV.js: ${opencvDuration.toFixed(2)}ms`);
                log('Init', `WASM: ${wasmDuration.toFixed(2)}ms`);
                logMemoryUsage('Initialization complete');

                // Auto-extract logs on success
                window.extractDebugLog();

            } catch (error) {
                const failTime = performance.now() - startTime;
                log('Init', `=== INITIALIZATION FAILED at ${failTime.toFixed(2)}ms ===`, 'error');
                log('Init', `Error type: ${error.constructor.name}`, 'error');
                log('Init', `Error message: ${error.message}`, 'error');
                log('Init', `Error stack: ${error.stack}`, 'error');

                updateStatus('✗ Initialization failed: ' + error.message, 'error');
                window.testHarnessError = error;

                // Log all init steps taken before failure
                log('Init', `Init steps before failure: ${JSON.stringify(window.initSteps)}`, 'error');

                // Extract logs on failure
                window.extractDebugLog();

                throw error;
            }
        }

        // Global error handlers
        window.addEventListener('error', (event) => {
            log('Global Error', `${event.message} at ${event.filename}:${event.lineno}:${event.colno}`, 'error');
            if (event.error) {
                log('Global Error', `Stack: ${event.error.stack}`, 'error');
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            log('Unhandled Rejection', `${event.reason}`, 'error');
            if (event.reason && event.reason.stack) {
                log('Unhandled Rejection', `Stack: ${event.reason.stack}`, 'error');
            }
        });

        // Start initialization
        log('Startup', 'Calling initialize()...');
        initialize().catch(err => {
            log('Fatal', `Initialization failed: ${err.message}`, 'error');
            log('Fatal', `Stack: ${err.stack}`, 'error');
            window.extractDebugLog();
        });

        // Export test utilities globally for Playwright tests
        window.testUtils = {
            ready: () => window.testHarnessReady,
            opencvJsReady: () => window.opencv_js_ready,
            opencvRustReady: () => window.opencv_rust_ready,
            loadTestImage: window.loadTestImage,
            matToImageData: window.matToImageData,
            imageDataToMat: window.imageDataToMat,
        };
    </script>
</body>
</html>
