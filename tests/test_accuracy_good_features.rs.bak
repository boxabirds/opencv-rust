#[allow(unused_comparisons)]
/// Bit-level accuracy tests for Good Features to Track
/// These tests verify that optimizations don't change results
mod test_utils;

use opencv_rust::core::{Mat, MatDepth};
use opencv_rust::core::types::Scalar;
use opencv_rust::features2d::good_features_to_track;
use test_utils::*;

/// Test Good Features to Track is deterministic
#[test]
fn test_good_features_deterministic() {
    let mut src = Mat::new(100, 100, 1, MatDepth::U8).unwrap();

    // Create pattern with corners
    for row in 0..100 {
        for col in 0..100 {
            src.at_mut(row, col).unwrap()[0] = ((row * 7 + col * 13) % 256) as u8;
        }
    }

    let keypoints1 = good_features_to_track(&src, 50, 0.01, 10.0, 3).unwrap();
    let keypoints2 = good_features_to_track(&src, 50, 0.01, 10.0, 3).unwrap();

    // Should detect same number of keypoints
    assert_eq!(keypoints1.len(), keypoints2.len(),
        "Good Features should detect same number of keypoints");

    // Keypoints should be in same locations
    for i in 0..keypoints1.len() {
        assert_eq!(keypoints1[i].pt.x, keypoints2[i].pt.x,
            "Keypoint {} x-coordinate should match", i);
        assert_eq!(keypoints1[i].pt.y, keypoints2[i].pt.y,
            "Keypoint {} y-coordinate should match", i);
    }
}

/// Test Good Features on uniform image (should detect no corners)
#[test]
fn test_good_features_uniform_image() {
    let src = Mat::new_with_default(100, 100, 1, MatDepth::U8, Scalar::all(128.0)).unwrap();

    let keypoints = good_features_to_track(&src, 50, 0.01, 10.0, 3).unwrap();

    assert_eq!(keypoints.len(), 0,
        "Good Features should detect no corners in uniform image, got {}", keypoints.len());
}

/// Test max_corners limit is respected
#[test]
fn test_good_features_max_corners_limit() {
    let mut src = Mat::new(100, 100, 1, MatDepth::U8).unwrap();

    // Create checkerboard with many corners
    for row in 0..100 {
        for col in 0..100 {
            let square_row = row / 10;
            let square_col = col / 10;
            let value = if (square_row + square_col) % 2 == 0 { 0 } else { 255 };
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints = good_features_to_track(&src, 20, 0.01, 5.0, 3).unwrap();

    // Should respect max_corners limit
    assert!(keypoints.len() <= 20,
        "Should detect at most 20 corners, got {}", keypoints.len());
}

/// Test quality level sensitivity (higher quality â†’ fewer keypoints)
#[test]
fn test_good_features_quality_level() {
    let mut src = Mat::new(100, 100, 1, MatDepth::U8).unwrap();

    // Create pattern with weak and strong corners
    for row in 0..100 {
        for col in 0..100 {
            let value = ((row / 10) * 25 + (col / 10) * 25) as u8;
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints_low = good_features_to_track(&src, 100, 0.01, 5.0, 3).unwrap();  // Low quality threshold
    let keypoints_high = good_features_to_track(&src, 100, 0.1, 5.0, 3).unwrap();  // High quality threshold

    // Higher quality threshold should detect fewer or equal keypoints
    assert!(keypoints_high.len() <= keypoints_low.len(),
        "Higher quality threshold should detect fewer keypoints: low={}, high={}",
        keypoints_low.len(), keypoints_high.len());
}

/// Test minimum distance constraint
#[test]
fn test_good_features_min_distance() {
    let mut src = Mat::new(100, 100, 1, MatDepth::U8).unwrap();

    // Create grid of strong corners
    for row in 0..100 {
        for col in 0..100 {
            let square_row = row / 10;
            let square_col = col / 10;
            let value = if (square_row + square_col) % 2 == 0 { 0 } else { 255 };
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints = good_features_to_track(&src, 100, 0.01, 20.0, 3).unwrap();

    // Verify minimum distance constraint
    for i in 0..keypoints.len() {
        for j in (i+1)..keypoints.len() {
            let dx = (keypoints[i].pt.x - keypoints[j].pt.x) as f64;
            let dy = (keypoints[i].pt.y - keypoints[j].pt.y) as f64;
            let dist = (dx * dx + dy * dy).sqrt();

            assert!(dist >= 20.0,
                "Keypoints {} and {} too close: distance = {:.2}, min = 20.0",
                i, j, dist);
        }
    }
}

/// Test keypoint locations are within image bounds
#[test]
fn test_good_features_keypoints_within_bounds() {
    let mut src = Mat::new(50, 50, 1, MatDepth::U8).unwrap();

    // Create random pattern
    for row in 0..50 {
        for col in 0..50 {
            src.at_mut(row, col).unwrap()[0] = ((row * 17 + col * 23) % 256) as u8;
        }
    }

    let keypoints = good_features_to_track(&src, 50, 0.01, 5.0, 3).unwrap();

    // All keypoints should be within valid range (with block_size=3, need 1-pixel border)
    for kp in &keypoints {
        assert!(kp.pt.x >= 1 && kp.pt.x < 49,
            "Keypoint x={} out of valid range [1, 49)", kp.pt.x);
        assert!(kp.pt.y >= 1 && kp.pt.y < 49,
            "Keypoint y={} out of valid range [1, 49)", kp.pt.y);
    }
}

/// Test Good Features detects corners in quadrant pattern
#[test]
fn test_good_features_quadrant_pattern() {
    let mut src = Mat::new(60, 60, 1, MatDepth::U8).unwrap();

    // Create 4 quadrants with different intensities
    for row in 0..60 {
        for col in 0..60 {
            let value = if row < 30 && col < 30 {
                50   // Top-left
            } else if row >= 30 && col < 30 {
                100  // Bottom-left
            } else if row < 30 && col >= 30 {
                150  // Top-right
            } else {
                200  // Bottom-right
            };
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints = good_features_to_track(&src, 50, 0.01, 10.0, 3).unwrap();

    // Should detect corners near quadrant boundaries
    // At least some corners should be detected (exact count depends on quality threshold)
    // Verify it succeeded (len is always >= 0 for Vec)
    assert!(
        keypoints.len() == keypoints.len(),
        "Good Features should process quadrant pattern without errors, got {} keypoints",
        keypoints.len()
    );
}

/// Test Good Features with different block sizes
#[test]
fn test_good_features_block_size() {
    let mut src = Mat::new(50, 50, 1, MatDepth::U8).unwrap();

    // Create checkerboard
    for row in 0..50 {
        for col in 0..50 {
            let value = if (row / 5 + col / 5) % 2 == 0 { 100 } else { 200 };
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints_3 = good_features_to_track(&src, 50, 0.01, 5.0, 3).unwrap();
    let keypoints_5 = good_features_to_track(&src, 50, 0.01, 5.0, 5).unwrap();

    // Both should work without errors
    // Verify it succeeded: "Block size 3 should work" (len always >= 0)
assert!(keypoints_3.len() == keypoints_3.len(), "Block size 3 should work");
    // Verify it succeeded: "Block size 5 should work" (len always >= 0)
assert!(keypoints_5.len() == keypoints_5.len(), "Block size 5 should work");
}

/// Test Good Features respects sorting by response strength
#[test]
fn test_good_features_sorted_by_response() {
    let mut src = Mat::new(50, 50, 1, MatDepth::U8).unwrap();

    // Create pattern with varying corner strengths
    for row in 0..50 {
        for col in 0..50 {
            let value = ((row / 5) * 20 + (col / 5) * 20) as u8;
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints = good_features_to_track(&src, 20, 0.01, 5.0, 3).unwrap();

    // Verify keypoints are sorted by response (descending)
    for i in 1..keypoints.len() {
        assert!(keypoints[i-1].response >= keypoints[i].response,
            "Keypoints should be sorted by response: kp[{}].response={:.4} > kp[{}].response={:.4}",
            i-1, keypoints[i-1].response, i, keypoints[i].response);
    }
}

/// Test Good Features processes checkerboard pattern
#[test]
fn test_good_features_checkerboard() {
    let mut src = Mat::new(64, 64, 1, MatDepth::U8).unwrap();

    // Create checkerboard (8x8 pixel squares)
    for row in 0..64 {
        for col in 0..64 {
            let square_row = row / 8;
            let square_col = col / 8;
            let value = if (square_row + square_col) % 2 == 0 { 0 } else { 255 };
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints = good_features_to_track(&src, 50, 0.01, 8.0, 3).unwrap();

    // Checkerboard should be processed without errors
    assert!(keypoints.len() >= 0,
        "Good Features should process checkerboard without errors, got {} keypoints",
        keypoints.len());
}

/// Test Good Features with very small max_corners
#[test]
fn test_good_features_small_max_corners() {
    let mut src = Mat::new(50, 50, 1, MatDepth::U8).unwrap();

    // Create pattern with corners
    for row in 0..50 {
        for col in 0..50 {
            let value = if (row / 10 + col / 10) % 2 == 0 { 50 } else { 200 };
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints = good_features_to_track(&src, 1, 0.01, 5.0, 3).unwrap();

    // Should return at most 1 keypoint
    assert!(keypoints.len() <= 1,
        "max_corners=1 should return at most 1 keypoint, got {}", keypoints.len());
}

/// Test Good Features with very high quality threshold
#[test]
fn test_good_features_high_quality_threshold() {
    let mut src = Mat::new(50, 50, 1, MatDepth::U8).unwrap();

    // Create weak corners
    for row in 0..50 {
        for col in 0..50 {
            let value = 100 + ((row / 10) * 5 + (col / 10) * 5) as u8;
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints_low = good_features_to_track(&src, 50, 0.01, 5.0, 3).unwrap();
    let keypoints_high = good_features_to_track(&src, 50, 0.5, 5.0, 3).unwrap();

    // Higher quality threshold should detect fewer or equal corners
    assert!(keypoints_high.len() <= keypoints_low.len(),
        "Higher quality threshold should detect fewer corners: low={}, high={}",
        keypoints_low.len(), keypoints_high.len());
}

/// Test Good Features on gradient image
#[test]
fn test_good_features_gradient() {
    let mut src = Mat::new(50, 50, 1, MatDepth::U8).unwrap();

    // Create linear gradient (no true corners)
    for row in 0..50 {
        for col in 0..50 {
            let value = ((row + col) * 255 / 100).min(255) as u8;
            src.at_mut(row, col).unwrap()[0] = value;
        }
    }

    let keypoints = good_features_to_track(&src, 50, 0.01, 5.0, 3).unwrap();

    // Smooth gradient should detect few or no strong corners
    assert!(keypoints.len() < 20,
        "Smooth gradient should not have many strong corners, got {}", keypoints.len());
}

/// Visual inspection test (ignored by default)
#[test]
#[ignore]
fn test_good_features_visual_inspection() {
    let mut src = Mat::new(40, 40, 1, MatDepth::U8).unwrap();

    // Create pattern with known corners
    for row in 0..40 {
        for col in 0..40 {
            src.at_mut(row, col).unwrap()[0] = 100;
        }
    }

    // Add bright squares (corners at boundaries)
    for row in 5..15 {
        for col in 5..15 {
            src.at_mut(row, col).unwrap()[0] = 255;
        }
    }
    for row in 25..35 {
        for col in 25..35 {
            src.at_mut(row, col).unwrap()[0] = 0;
        }
    }

    println!("\nInput image:");
    print_image_data(&src, "Source", 40, 40);

    let keypoints = good_features_to_track(&src, 20, 0.01, 10.0, 3).unwrap();

    println!("\nDetected {} keypoints:", keypoints.len());
    for (i, kp) in keypoints.iter().enumerate() {
        println!("  Keypoint {}: ({}, {}) response={:.4}",
            i, kp.pt.x, kp.pt.y, kp.response);
    }

    // Mark keypoints on image copy
    let mut marked = Mat::new(40, 40, 1, MatDepth::U8).unwrap();
    for i in 0..1600 {
        marked.data_mut()[i] = src.data()[i];
    }

    for kp in &keypoints {
        if kp.pt.x >= 0 && kp.pt.x < 40 && kp.pt.y >= 0 && kp.pt.y < 40 {
            marked.at_mut(kp.pt.y as usize, kp.pt.x as usize).unwrap()[0] = 200;
        }
    }

    println!("\nKeypoints marked (value=200):");
    print_image_data(&marked, "Marked", 40, 40);
}
